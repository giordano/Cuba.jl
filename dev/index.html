<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Cuba · Cuba</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>Cuba</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Cuba</a><ul class="internal"><li><a class="tocitem" href="#Introduction"><span>Introduction</span></a></li><li><a class="tocitem" href="#Installation"><span>Installation</span></a></li><li><a class="tocitem" href="#Usage"><span>Usage</span></a></li><li><a class="tocitem" href="#Vectorization"><span>Vectorization</span></a></li><li><a class="tocitem" href="#Examples"><span>Examples</span></a></li><li><a class="tocitem" href="#Performance"><span>Performance</span></a></li><li><a class="tocitem" href="#Related-projects"><span>Related projects</span></a></li><li><a class="tocitem" href="#Development"><span>Development</span></a></li><li><a class="tocitem" href="#License"><span>License</span></a></li><li><a class="tocitem" href="#Credits"><span>Credits</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Cuba</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Cuba</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/giordano/Cuba.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Cuba"><a class="docs-heading-anchor" href="#Cuba">Cuba</a><a id="Cuba-1"></a><a class="docs-heading-anchor-permalink" href="#Cuba" title="Permalink"></a></h1><h2 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h2><p><a href="https://github.com/giordano/Cuba.jl"><code>Cuba.jl</code></a> is a <a href="http://julialang.org/">Julia</a> library for multidimensional <a href="https://en.wikipedia.org/wiki/Numerical_integration">numerical integration</a> of real-valued functions of real arguments, using different algorithms.</p><p>This is just a Julia wrapper around the C <a href="http://www.feynarts.de/cuba/">Cuba library</a>, version 4.2, by <strong>Thomas Hahn</strong>.  All the credits goes to him for the underlying functions, blame me for any problem with the Julia interface.</p><p>All algorithms provided by Cuba library are supported in <code>Cuba.jl</code>:</p><ul><li><p><a href="https://en.wikipedia.org/wiki/VEGAS_algorithm">Vegas</a>:</p><table><tr><th style="text-align: right">Basic integration method</th><th style="text-align: right">Type</th><th style="text-align: right"><a href="https://en.wikipedia.org/wiki/Variance_reduction">Variance reduction</a></th></tr><tr><td style="text-align: right"><a href="https://en.wikipedia.org/wiki/Sobol_sequence">Sobol quasi-random sample</a></td><td style="text-align: right"><a href="https://en.wikipedia.org/wiki/Monte_Carlo_integration">Monte Carlo</a></td><td style="text-align: right"><a href="https://en.wikipedia.org/wiki/Importance_sampling">importance sampling</a></td></tr><tr><td style="text-align: right"><a href="https://en.wikipedia.org/wiki/Mersenne_Twister">Mersenne Twister pseudo-random sample</a></td><td style="text-align: right">&quot;</td><td style="text-align: right">&quot;</td></tr><tr><td style="text-align: right"><a href="http://arxiv.org/abs/hep-lat/9309020">Ranlux pseudo-random sample</a></td><td style="text-align: right">&quot;</td><td style="text-align: right">&quot;</td></tr></table></li><li><p>Suave</p><table><tr><th style="text-align: right">Basic integration method</th><th style="text-align: right">Type</th><th style="text-align: right">Variance reduction</th></tr><tr><td style="text-align: right">Sobol quasi-random sample</td><td style="text-align: right">Monte Carlo</td><td style="text-align: right">globally <a href="https://en.wikipedia.org/wiki/Adaptive_quadrature">adaptive subdivision</a> and importance sampling</td></tr><tr><td style="text-align: right">Mersenne Twister pseudo-random sample</td><td style="text-align: right">&quot;</td><td style="text-align: right">&quot;</td></tr><tr><td style="text-align: right">Ranlux pseudo-random sample</td><td style="text-align: right">&quot;</td><td style="text-align: right">&quot;</td></tr></table></li><li><p>Divonne</p><table><tr><th style="text-align: right">Basic integration method</th><th style="text-align: right">Type</th><th style="text-align: right">Variance reduction</th></tr><tr><td style="text-align: right">Korobov quasi-random sample</td><td style="text-align: right">Monte Carlo</td><td style="text-align: right"><a href="https://en.wikipedia.org/wiki/Stratified_sampling">stratified sampling</a> aided by methods from numerical optimization</td></tr><tr><td style="text-align: right">Sobol quasi-random sample</td><td style="text-align: right">&quot;</td><td style="text-align: right">&quot;</td></tr><tr><td style="text-align: right">Mersenne Twister pseudo-random sample</td><td style="text-align: right">&quot;</td><td style="text-align: right">&quot;</td></tr><tr><td style="text-align: right">Ranlux pseudo-random sample</td><td style="text-align: right">&quot;</td><td style="text-align: right">&quot;</td></tr><tr><td style="text-align: right">cubature rules</td><td style="text-align: right">deterministic</td><td style="text-align: right">&quot;</td></tr></table></li><li><p>Cuhre</p><table><tr><th style="text-align: right">Basic integration method</th><th style="text-align: right">Type</th><th style="text-align: right">Variance reduction</th></tr><tr><td style="text-align: right">cubature rules</td><td style="text-align: right">deterministic</td><td style="text-align: right">globally adaptive subdivision</td></tr></table></li></ul><p>For more details on the algorithms see the manual included in Cuba library and available in <code>deps/usr/share/cuba.pdf</code> after successful installation of <code>Cuba.jl</code>.</p><p>Integration is always performed on the <span>$n$</span>-dimensional <a href="https://en.wikipedia.org/wiki/Hypercube">unit hypercube</a> <span>$[0, 1]^{n}$</span>.</p><div class="admonition is-success"><header class="admonition-header">Integrate over different domains</header><div class="admonition-body"><p>If you want to compute an integral over a different set, you have to scale the integrand function in order to have an equivalent integral on <span>$[0, 1]^{n}$</span> using <a href="https://en.wikipedia.org/wiki/Integration_by_substitution">substitution rules</a>. For example, recall that in one dimension</p><p class="math-container">\[\int_{a}^{b} f(x)\,\mathrm{d}x = \int_{0}^{1} f(a + (b - a) y) (b -
a)\,\mathrm{d}y\]</p><p>where the final <span>$(b - a)$</span> is the one-dimensional version of the Jacobian.</p><p>Integration over a semi-infinite or an inifite domain is a bit trickier, but you can follow <a href="http://ab-initio.mit.edu/wiki/index.php/Cubature#Infinite_intervals">this advice</a> from Steven G. Johnson: to compute an integral over a semi-infinite interval, you can perform the change of variables <span>$x=a+y/(1-y)$</span>:</p><p class="math-container">\[\int_{a}^{\infty} f(x)\,\mathrm{d}x = \int_{0}^{1}
f\left(a + \frac{y}{1 - y}\right)\frac{1}{(1 - y)^2}\,\mathrm{d}y\]</p><p>For an infinite interval, you can perform the change of variables <span>$x=(2y - 1)/((1 - y)y)$</span>:</p><p class="math-container">\[\int_{-\infty}^{\infty} f(x)\,\mathrm{d}x = \int_{0}^{1}
f\left(\frac{2y - 1}{(1 - y)y}\right)\frac{2y^2 - 2y + 1}{(1 -
y)^2y^2}\,\mathrm{d}y\]</p><p>In addition, recall that for an <a href="https://en.wikipedia.org/wiki/Even_and_odd_functions#Even_functions">even function</a> <span>$\int_{-\infty}^{\infty} f(x)\,\mathrm{d}x = 2\int_{0}^{\infty}f(x)\,\mathrm{d}x$</span>, while the integral of an <a href="https://en.wikipedia.org/wiki/Even_and_odd_functions#Odd_functions">odd function</a> over the infinite interval <span>$(-\infty, \infty)$</span> is zero.</p><p>All this generalizes straightforwardly to more than one dimension. In <a href="#Examples">Examples</a> section you can find the computation of a 3-dimensional <a href="#Integral-with-non-constant-boundaries-1">integral with non-constant boundaries</a> using <code>Cuba.jl</code> and two <a href="#Integrals-over-Infinite-Domains-1">integrals over infinite domains</a>.</p></div></div><p><code>Cuba.jl</code> is available on all platforms supported by Julia.</p><h2 id="Installation"><a class="docs-heading-anchor" href="#Installation">Installation</a><a id="Installation-1"></a><a class="docs-heading-anchor-permalink" href="#Installation" title="Permalink"></a></h2><p>The latest version of <code>Cuba.jl</code> is available for Julia 1.3 and later versions, and can be installed with <a href="https://docs.julialang.org/en/v1/stdlib/Pkg/">Julia built-in package manager</a>. In a Julia session run the commands</p><pre><code class="language-julia hljs">pkg&gt; update
pkg&gt; add Cuba</code></pre><p>Older versions are also available for Julia 0.4-1.2.</p><h2 id="Usage"><a class="docs-heading-anchor" href="#Usage">Usage</a><a id="Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Usage" title="Permalink"></a></h2><p>After installing the package, run</p><pre><code class="language-julia hljs">using Cuba</code></pre><p>or put this command into your Julia script.</p><p><code>Cuba.jl</code> provides the following functions to integrate:</p><article class="docstring"><header><a class="docstring-binding" id="Cuba.vegas" href="#Cuba.vegas"><code>Cuba.vegas</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">vegas(integrand, ndim=1, ncomp=1[, keywords]) -&gt; integral, error, probability, neval, fail, nregions</code></pre><p>Calculate integral of <code>integrand</code> over the unit hypercube in <code>ndim</code> dimensions using Vegas algorithm.  <code>integrand</code> is a vectorial function with <code>ncomp</code> components.  <code>ndim</code> and <code>ncomp</code> default to 1.</p><p>Accepted keywords:</p><ul><li><code>nvec</code></li><li><code>rtol</code></li><li><code>atol</code></li><li><code>flags</code></li><li><code>seed</code></li><li><code>minevals</code></li><li><code>maxevals</code></li><li><code>nstart</code></li><li><code>nincrease</code></li><li><code>nbatch</code></li><li><code>gridno</code></li><li><code>statefile</code></li><li><code>spin</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/giordano/Cuba.jl/blob/8acad792ba66e41c1e3b909c199468b13ec487cf/src/vegas.jl#L75-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Cuba.suave" href="#Cuba.suave"><code>Cuba.suave</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">suave(integrand, ndim=1, ncomp=1[, keywords]) -&gt; integral, error, probability, neval, fail, nregions</code></pre><p>Calculate integral of <code>integrand</code> over the unit hypercube in <code>ndim</code> dimensions using Suave algorithm.  <code>integrand</code> is a vectorial function with <code>ncomp</code> components. <code>ndim</code> and <code>ncomp</code> default to 1.</p><p>Accepted keywords:</p><ul><li><code>nvec</code></li><li><code>rtol</code></li><li><code>atol</code></li><li><code>flags</code></li><li><code>seed</code></li><li><code>minevals</code></li><li><code>maxevals</code></li><li><code>nnew</code></li><li><code>nmin</code></li><li><code>flatness</code></li><li><code>statefile</code></li><li><code>spin</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/giordano/Cuba.jl/blob/8acad792ba66e41c1e3b909c199468b13ec487cf/src/suave.jl#L74-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Cuba.divonne" href="#Cuba.divonne"><code>Cuba.divonne</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">divonne(integrand, ndim=2, ncomp=1[, keywords]) -&gt; integral, error, probability, neval, fail, nregions</code></pre><p>Calculate integral of <code>integrand</code> over the unit hypercube in <code>ndim</code> dimensions using Divonne algorithm.  <code>integrand</code> is a vectorial function with <code>ncomp</code> components. <code>ncomp</code> defaults to 1, <code>ndim</code> defaults to 2 and must be ≥ 2.</p><p>Accepted keywords:</p><ul><li><code>nvec</code></li><li><code>rtol</code></li><li><code>atol</code></li><li><code>flags</code></li><li><code>seed</code></li><li><code>minevals</code></li><li><code>maxevals</code></li><li><code>key1</code></li><li><code>key2</code></li><li><code>key3</code></li><li><code>maxpass</code></li><li><code>border</code></li><li><code>maxchisq</code></li><li><code>mindeviation</code></li><li><code>ngiven</code></li><li><code>ldxgiven</code></li><li><code>xgiven</code></li><li><code>nextra</code></li><li><code>peakfinder</code></li><li><code>statefile</code></li><li><code>spin</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/giordano/Cuba.jl/blob/8acad792ba66e41c1e3b909c199468b13ec487cf/src/divonne.jl#L93-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Cuba.cuhre" href="#Cuba.cuhre"><code>Cuba.cuhre</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">cuhre(integrand, ndim=2, ncomp=1[, keywords]) -&gt; integral, error, probability, neval, fail, nregions</code></pre><p>Calculate integral of <code>integrand</code> over the unit hypercube in <code>ndim</code> dimensions using Cuhre algorithm.  <code>integrand</code> is a vectorial function with <code>ncomp</code> components.  <code>ncomp</code> defaults to 1, <code>ndim</code> defaults to 2 and must be ≥ 2.</p><p>Accepted keywords:</p><ul><li><code>nvec</code></li><li><code>rtol</code></li><li><code>atol</code></li><li><code>flags</code></li><li><code>minevals</code></li><li><code>maxevals</code></li><li><code>key</code></li><li><code>statefile</code></li><li><code>spin</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/giordano/Cuba.jl/blob/8acad792ba66e41c1e3b909c199468b13ec487cf/src/cuhre.jl#L67-L85">source</a></section></article><p>Large parts of the following sections are borrowed from Cuba manual. Refer to it for more information on the details.</p><p><code>Cuba.jl</code> wraps the 64-bit integers functions of Cuba library, in order to push the range of certain counters to its full extent. In detail, the following arguments:</p><ul><li>for Vegas: <code>nvec</code>, <code>minevals</code>, <code>maxevals</code>, <code>nstart</code>, <code>nincrease</code>,   <code>nbatch</code>, <code>neval</code>,</li><li>for Suave: <code>nvec</code>, <code>minevals</code>, <code>maxevals</code>, <code>nnew</code>, <code>nmin</code>, <code>neval</code>,</li><li>for Divonne: <code>nvec</code>, <code>minevals</code>, <code>maxevals</code>, <code>ngiven</code>, <code>nextra</code>,   <code>neval</code>,</li><li>for Cuhre: <code>nvec</code>, <code>minevals</code>, <code>maxevals</code>, <code>neval</code>,</li></ul><p>are passed to the Cuba library as 64-bit integers, so they are limited to be at most</p><pre><code class="language-julia-repl hljs">julia&gt; typemax(Int64)
9223372036854775807</code></pre><p>There is no way to overcome this limit. See the following sections for the meaning of each argument.</p><h3 id="Arguments"><a class="docs-heading-anchor" href="#Arguments">Arguments</a><a id="Arguments-1"></a><a class="docs-heading-anchor-permalink" href="#Arguments" title="Permalink"></a></h3><p>The only mandatory argument of integrator functions is:</p><ul><li><code>integrand</code> (type: <code>Function</code>): the function to be integrated</li></ul><p>Optional positional arguments are:</p><ul><li><code>ndim</code> (type: <code>Integer</code>): the number of dimensions of the   integratation domain. If omitted, defaults to 1 in <code>vegas</code> and   <code>suave</code>, to 2 in <code>divonne</code> and <code>cuhre</code>. Note: <code>ndim</code> must be at   least 2 with the latest two methods.</li><li><code>ncomp</code> (type: <code>Integer</code>): the number of components of the   integrand. Default to 1 if omitted</li></ul><p><code>integrand</code> should be a function <code>integrand(x, f)</code> taking two arguments:</p><ul><li>the input vector <code>x</code> of length <code>ndim</code></li><li>the output vector <code>f</code> of length <code>ncomp</code>, used to set the value of   each component of the integrand at point <code>x</code></li></ul><p><code>x</code> and <code>f</code> are matrices with dimensions <code>(ndim, nvec)</code> and <code>(ncomp, nvec)</code>, respectively, when <code>nvec</code> &gt; 1. See the <a href="#Vectorization">Vectorization</a> section below for more information.</p><p>Also <a href="https://docs.julialang.org/en/v1/manual/functions/#man-anonymous-functions-1">anonymous functions</a> are allowed as <code>integrand</code>. For those familiar with <code>Cubature.jl</code> package, this is the same syntax used for integrating vector-valued functions.</p><p>For example, the integral</p><p class="math-container">\[\int_{0}^{1} \cos (x) \,\mathrm{d}x = \sin(1) = 0.8414709848078965\]</p><p>can be computed with one of the following commands</p><pre><code class="language-julia-repl hljs">julia&gt; vegas((x, f) -&gt; f[1] = cos(x[1]))
Component:
 1: 0.841491000525961 ± 5.2708169786483034e-5 (prob.: 0.028607201258847748)
Integrand evaluations: 13500
Number of subregions:  0
Note: The desired accuracy was reached

julia&gt; suave((x, f) -&gt; f[1] = cos(x[1]))
Component:
 1: 0.8413748866950329 ± 7.772872640815592e-5 (prob.: 1.0)
Integrand evaluations: 23000
Number of subregions:  23
Note: The desired accuracy was reached

julia&gt; divonne((x, f) -&gt; f[1] = cos(x[1]))
Component:
 1: 0.841468071955942 ± 5.3955070531551656e-5 (prob.: 1.1102230246251565e-16)
Integrand evaluations: 1686
Number of subregions:  14
Note: The desired accuracy was reached

julia&gt; cuhre((x, f) -&gt; f[1] = cos(x[1]))
Component:
 1: 0.8414709848078967 ± 2.304857594221477e-15 (prob.: 4.869900880782919e-5)
Integrand evaluations: 195
Number of subregions:  2
Note: The desired accuracy was reached</code></pre><p>In section <a href="#Examples">Examples</a> you can find more complete examples.  Note that <code>x</code> and <code>f</code> are both arrays with type <code>Float64</code>, so <code>Cuba.jl</code> can be used to integrate real-valued functions of real arguments. See how to work with a <a href="#Complex-integrand-1">complex integrand</a>.</p><div class="admonition is-info"><header class="admonition-header">Limit on number of components</header><div class="admonition-body"><p>The Cuba C library has a hard limit on the number of components that you can use for your integrand function, which is set at compile time.  The build of the library currently used by <code>Cuba.jl</code> has this limit set to 1024, the default.  If you use an integrand with a larger number of components, the integration will fail, which you can detect by checking the <code>fail</code> field of the <code>Integral</code> output object, which will be non-zero, see the &quot;<a href="#Output">Output</a>&quot; section below.</p><p>If you need to integrate functions with components larger than 1024, consider using other packages which don&#39;t have this limitation, like <a href="https://github.com/JuliaMath/HCubature.jl"><code>HCubature.jl</code></a> or <a href="https://github.com/JuliaMath/Cubature.jl"><code>Cubature.jl</code></a>.</p></div></div><div class="admonition is-info"><header class="admonition-header">Compatibility</header><div class="admonition-body"><p>If you used <code>Cuba.jl</code> until version 0.0.4, be aware that the user interface has been reworked in version 0.0.5 in a backward incompatible way.</p></div></div><h3 id="Optional-Keywords"><a class="docs-heading-anchor" href="#Optional-Keywords">Optional Keywords</a><a id="Optional-Keywords-1"></a><a class="docs-heading-anchor-permalink" href="#Optional-Keywords" title="Permalink"></a></h3><p>All other arguments required by Cuba integrator routines can be passed as optional keywords. <code>Cuba.jl</code> uses some reasonable default values in order to enable users to invoke integrator functions with a minimal set of arguments. Anyway, if you want to make sure future changes to some default values of keywords will not affect your current script, explicitely specify the value of the keywords.</p><h4 id="Common-Keywords"><a class="docs-heading-anchor" href="#Common-Keywords">Common Keywords</a><a id="Common-Keywords-1"></a><a class="docs-heading-anchor-permalink" href="#Common-Keywords" title="Permalink"></a></h4><p>These are optional keywords common to all functions:</p><ul><li><p><code>nvec</code> (type: <code>Integer</code>, default: <code>1</code>): the maximum number of points to be   given to the integrand routine in each invocation. Usually this is 1 but if   the integrand can profit from e.g. Single Instruction Multiple Data (SIMD)   vectorization, a larger value can be chosen. See <a href="#Vectorization">Vectorization</a>   section.</p></li><li><p><code>rtol</code> (type: <code>Real</code>, default: <code>1e-4</code>), and <code>atol</code> (type: <code>Real</code>,   default: <code>1e-12</code>): the requested relative   (<span>$\varepsilon_{\text{rel}}$</span>) and absolute   (<span>$\varepsilon_{\text{abs}}$</span>) accuracies. The integrator tries to   find an estimate <span>$\hat{I}$</span> for the integral <span>$I$</span> which for every   component <span>$c$</span> fulfills <span>$|\hat{I}_c - I_c|\leq   \max(\varepsilon_{\text{abs}}, \varepsilon_{\text{rel}} |I_c|)$</span>.</p></li><li><p><code>flags</code> (type: <code>Integer</code>, default: <code>0</code>): flags governing the   integration:</p><ul><li><p>Bits 0 and 1 are taken as the verbosity level, i.e. <code>0</code> to <code>3</code>,   unless the <code>CUBAVERBOSE</code> environment variable contains an even   higher value (used for debugging).</p><p>Level <code>0</code> does not print any output, level <code>1</code> prints &quot;reasonable&quot;   information on the progress of the integration, level <code>2</code> also echoes   the input parameters, and level <code>3</code> further prints the subregion results   (if applicable).</p></li><li><p>Bit 2 = <code>0</code>: all sets of samples collected on a subregion during   the various iterations or phases contribute to the final result.</p><p>Bit 2 = <code>1</code>, only the last (largest) set of samples is used in   the final result.</p></li><li><p>(Vegas and Suave only)</p><p>Bit 3 = <code>0</code>, apply additional smoothing to the importance   function, this moderately improves convergence for many   integrands.</p><p>Bit 3 = <code>1</code>, use the importance function without smoothing, this   should be chosen if the integrand has sharp edges.</p></li><li><p>Bit 4 = <code>0</code>, delete the state file (if one is chosen) when the   integration terminates successfully.</p><p>Bit 4 = <code>1</code>, retain the state file.</p></li><li><p>(Vegas only)</p><p>Bit 5 = <code>0</code>, take the integrator&#39;s state from the state file,   if one is present.</p><p>Bit 5 = <code>1</code>, reset the integrator&#39;s state even if a state file   is present, i.e. keep only the grid. Together with Bit 4 this   allows a grid adapted by one integration to be used for another   integrand.</p></li><li><p>Bits 8–31 =: <code>level</code> determines the random-number generator.</p></li></ul><p>To select e.g. last samples only and verbosity level 2, pass   <code>6 = 4 + 2</code> for the flags.</p></li><li><p><code>seed</code> (type: <code>Integer</code>, default: <code>0</code>): the seed for the pseudo-random-number generator. This keyword is not available for <a href="#Cuba.cuhre"><code>cuhre</code></a>. The random-number generator is chosen as follows:</p><table><tr><th style="text-align: right"><code>seed</code></th><th style="text-align: right"><code>level</code> (bits 8–31 of <code>flags</code>)</th><th style="text-align: right">Generator</th></tr><tr><td style="text-align: right">zero</td><td style="text-align: right">N/A</td><td style="text-align: right">Sobol (quasi-random)</td></tr><tr><td style="text-align: right">non-zero</td><td style="text-align: right">zero</td><td style="text-align: right">Mersenne Twister (pseudo-random)</td></tr><tr><td style="text-align: right">non-zero</td><td style="text-align: right">non-zero</td><td style="text-align: right">Ranlux (pseudo-random)</td></tr></table><p>Ranlux implements Marsaglia and Zaman&#39;s 24-bit RCARRY algorithm with generation period <span>$p$</span>, i.e. for every 24 generated numbers used, another <span>$p - 24$</span> are skipped. The luxury level is encoded in <code>level</code> as follows:</p><ul><li>Level 1 (<span>$p = 48$</span>): very long period, passes the gap test but fails spectral test.</li><li>Level 2 (<span>$p = 97$</span>): passes all known tests, but theoretically still defective.</li><li>Level 3 (<span>$p = 223$</span>): any theoretically possible correlations have very small chance of being observed.</li><li>Level 4 (<span>$p = 389$</span>): highest possible luxury, all 24 bits chaotic.</li></ul><p>Levels 5–23 default to 3, values above 24 directly specify the period <span>$p$</span>. Note that Ranlux&#39;s original level 0, (mis)used for selecting Mersenne Twister in Cuba, is equivalent to <code>level</code> = <code>24</code>.</p></li><li><p><code>minevals</code> (type: <code>Real</code>, default: <code>0</code>): the minimum number of   integrand evaluations required</p></li><li><p><code>maxevals</code> (type: <code>Real</code>, default: <code>1000000</code>): the (approximate)   maximum number of integrand evaluations allowed</p></li><li><p><code>statefile</code> (type: <code>AbstractString</code>, default: <code>&quot;&quot;</code>): a filename for   storing the internal state. To not store the internal state, put   <code>&quot;&quot;</code> (empty string, this is the default) or <code>C_NULL</code> (C null   pointer).</p><p>Cuba can store its entire internal state (i.e. all the information   to resume an interrupted integration) in an external file. The state   file is updated after every iteration. If, on a subsequent   invocation, a Cuba routine finds a file of the specified name, it   loads the internal state and continues from the point it left off.   Needless to say, using an existing state file with a different   integrand generally leads to wrong results.</p><p>This feature is useful mainly to define &quot;check-points&quot; in   long-running integrations from which the calculation can be   restarted.</p><p>Once the integration reaches the prescribed accuracy, the state file   is removed, unless bit 4 of <code>flags</code> (see above) explicitly requests   that it be kept.</p></li><li><p><code>spin</code> (type: <code>Ptr{Void}</code>, default: <code>C_NULL</code>): this is the   placeholder for the &quot;spinning cores&quot; pointer. <code>Cuba.jl</code> does not   support parallelization, so this keyword should not have a value   different from <code>C_NULL</code>.</p></li></ul><h4 id="Vegas-Specific-Keywords"><a class="docs-heading-anchor" href="#Vegas-Specific-Keywords">Vegas-Specific Keywords</a><a id="Vegas-Specific-Keywords-1"></a><a class="docs-heading-anchor-permalink" href="#Vegas-Specific-Keywords" title="Permalink"></a></h4><p>These optional keywords can be passed only to <a href="#Cuba.vegas"><code>vegas</code></a>:</p><ul><li><p><code>nstart</code> (type: <code>Integer</code>, default: <code>1000</code>): the number of integrand   evaluations per iteration to start with</p></li><li><p><code>nincrease</code> (type: <code>Integer</code>, default: <code>500</code>): the increase in the   number of integrand evaluations per iteration</p></li><li><p><code>nbatch</code> (type: <code>Integer</code>, default: <code>1000</code>): the batch size for   sampling</p><p>Vegas samples points not all at once, but in batches of size   <code>nbatch</code>, to avoid excessive memory consumption. <code>1000</code> is a   reasonable value, though it should not affect performance too much</p></li><li><p><code>gridno</code> (type: <code>Integer</code>, default: <code>0</code>): the slot in the internal   grid table.</p><p>It may accelerate convergence to keep the grid accumulated during   one integration for the next one, if the integrands are reasonably   similar to each other. Vegas maintains an internal table with space   for ten grids for this purpose. The slot in this grid is specified   by <code>gridno</code>.</p><p>If a grid number between <code>1</code> and <code>10</code> is selected, the grid is not   discarded at the end of the integration, but stored in the   respective slot of the table for a future invocation. The grid is   only re-used if the dimension of the subsequent integration is the   same as the one it originates from.</p><p>In repeated invocations it may become necessary to flush a slot in   memory, in which case the negative of the grid number should be set.</p></li></ul><h4 id="Suave-Specific-Keywords"><a class="docs-heading-anchor" href="#Suave-Specific-Keywords">Suave-Specific Keywords</a><a id="Suave-Specific-Keywords-1"></a><a class="docs-heading-anchor-permalink" href="#Suave-Specific-Keywords" title="Permalink"></a></h4><p>These optional keywords can be passed only to <a href="#Cuba.suave"><code>suave</code></a>:</p><ul><li><code>nnew</code> (type: <code>Integer</code>, default: <code>1000</code>): the number of new   integrand evaluations in each subdivision</li><li><code>nmin</code> (type: <code>Integer</code>, default: <code>2</code>): the minimum number of   samples a former pass must contribute to a subregion to be   considered in that region&#39;s compound integral value. Increasing   <code>nmin</code> may reduce jumps in the <span>$\chi^2$</span> value</li><li><code>flatness</code> (type: <code>Real</code>, default: <code>.25</code>): the type of norm used to   compute the fluctuation of a sample. This determines how prominently   &quot;outliers&quot;, i.e. individual samples with a large fluctuation,   figure in the total fluctuation, which in turn determines how a   region is split up. As suggested by its name, <code>flatness</code> should be   chosen large for &quot;flat&quot; integrands and small for &quot;volatile&quot;   integrands with high peaks. Note that since <code>flatness</code> appears in   the exponent, one should not use too large values (say, no more than   a few hundred) lest terms be truncated internally to prevent   overflow.</li></ul><h4 id="Divonne-Specific-Keywords"><a class="docs-heading-anchor" href="#Divonne-Specific-Keywords">Divonne-Specific Keywords</a><a id="Divonne-Specific-Keywords-1"></a><a class="docs-heading-anchor-permalink" href="#Divonne-Specific-Keywords" title="Permalink"></a></h4><p>These optional keywords can be passed only to <a href="#Cuba.divonne"><code>divonne</code></a>:</p><ul><li><p><code>key1</code> (type: <code>Integer</code>, default: <code>47</code>): determines sampling in the   partitioning phase: <code>key1</code> <span>$= 7, 9, 11, 13$</span> selects the cubature   rule of degree <code>key1</code>. Note that the degree-11 rule is available   only in 3 dimensions, the degree-13 rule only in 2 dimensions.</p><p>For other values of <code>key1</code>, a quasi-random sample of <span>$n_1 =   |\verb|key1||$</span> points is used, where the sign of <code>key1</code> determines   the type of sample,</p><ul><li><p><code>key1</code> <span>$&gt; 0$</span>, use a Korobov quasi-random sample,</p></li><li><p><code>key1</code> <span>$&lt; 0$</span>, use a &quot;standard&quot; sample (a Sobol quasi-random   sample if <code>seed</code> <span>$= 0$</span>, otherwise a pseudo-random sample).</p></li><li><p><code>key2</code> (type: <code>Integer</code>, default: <code>1</code>): determines sampling in   the final integration phase:</p><p><code>key2</code> <span>$= 7, 9, 11, 13$</span> selects the cubature rule of degree   <code>key2</code>. Note that the degree-11 rule is available only in 3   dimensions, the degree-13 rule only in 2 dimensions.</p><p>For other values of <code>key2</code>, a quasi-random sample is used, where   the sign of <code>key2</code> determines the type of sample,</p><ul><li><code>key2</code> <span>$&gt; 0$</span>, use a Korobov quasi-random sample,</li><li><code>key2</code> <span>$&lt; 0$</span>, use a &quot;standard&quot; sample (see description of   <code>key1</code> above),</li></ul><p>and <span>$n_2 = |\verb|key2||$</span> determines the number of points,</p><ul><li><span>$n_2\geq 40$</span>, sample <span>$n_2$</span> points,</li><li><span>$n_2 &lt; 40$</span>, sample <span>$n_2\,n_{\text{need}}$</span> points, where   <span>$n_{\text{need}}$</span> is the number of points needed to reach   the prescribed accuracy, as estimated by Divonne from the   results of the partitioning phase</li></ul></li></ul></li><li><p><code>key3</code> (type: <code>Integer</code>, default: <code>1</code>): sets the strategy for the   refinement phase:</p><p><code>key3</code> <span>$= 0$</span>, do not treat the subregion any further.</p><p><code>key3</code> <span>$= 1$</span>, split the subregion up once more.</p><p>Otherwise, the subregion is sampled a third time with <code>key3</code>   specifying the sampling parameters exactly as <code>key2</code> above.</p></li><li><p><code>maxpass</code> (type: <code>Integer</code>, default: <code>5</code>): controls the thoroughness   of the partitioning phase: The partitioning phase terminates when   the estimated total number of integrand evaluations (partitioning   plus final integration) does not decrease for <code>maxpass</code> successive   iterations.</p><p>A decrease in points generally indicates that Divonne discovered new   structures of the integrand and was able to find a more effective   partitioning. <code>maxpass</code> can be understood as the number of   &quot;safety&quot; iterations that are performed before the partition is   accepted as final and counting consequently restarts at zero   whenever new structures are found.</p></li><li><p><code>border</code> (type: <code>Real</code>, default: <code>0.</code>): the width of the border of   the integration region. Points falling into this border region will   not be sampled directly, but will be extrapolated from two samples   from the interior. Use a non-zero <code>border</code> if the integrand function   cannot produce values directly on the integration boundary</p></li><li><p><code>maxchisq</code> (type: <code>Real</code>, default: <code>10.</code>): the <span>$\chi^2$</span> value a   single subregion is allowed to have in the final integration phase.   Regions which fail this <span>$\chi^2$</span> test and whose sample averages   differ by more than <code>mindeviation</code> move on to the refinement phase.</p></li><li><p><code>mindeviation</code> (type: <code>Real</code>, default: <code>0.25</code>): a bound, given as   the fraction of the requested error of the entire integral, which   determines whether it is worthwhile further examining a region that   failed the <span>$\chi^2$</span> test. Only if the two sampling averages obtained   for the region differ by more than this bound is the region further   treated.</p></li><li><p><code>ngiven</code> (type: <code>Integer</code>, default: <code>0</code>): the number of points in   the <code>xgiven</code> array</p></li><li><p><code>ldxgiven</code> (type: <code>Integer</code>, default: <code>0</code>): the leading dimension of   <code>xgiven</code>, i.e. the offset between one point and the next in memory</p></li><li><p><code>xgiven</code> (type: <code>AbstractArray{Real}</code>, default:   <code>zeros(Cdouble, ldxgiven, ngiven)</code>): a list of points where the   integrand might have peaks. Divonne will consider these points when   partitioning the integration region. The idea here is to help the   integrator find the extrema of the integrand in the presence of very   narrow peaks. Even if only the approximate location of such peaks is   known, this can considerably speed up convergence.</p></li><li><p><code>nextra</code> (type: <code>Integer</code>, default: <code>0</code>): the maximum number of   extra points the peak-finder subroutine will return. If <code>nextra</code> is   zero, <code>peakfinder</code> is not called and an arbitrary object may be   passed in its place, e.g. just 0</p></li><li><p><code>peakfinder</code> (type: <code>Ptr{Void}</code>, default: <code>C_NULL</code>): the peak-finder   subroutine</p></li></ul><h4 id="Cuhre-Specific-Keyword"><a class="docs-heading-anchor" href="#Cuhre-Specific-Keyword">Cuhre-Specific Keyword</a><a id="Cuhre-Specific-Keyword-1"></a><a class="docs-heading-anchor-permalink" href="#Cuhre-Specific-Keyword" title="Permalink"></a></h4><p>This optional keyword can be passed only to <a href="#Cuba.cuhre"><code>cuhre</code></a>:</p><ul><li><p><code>key</code> (type: <code>Integer</code>, default: <code>0</code>): chooses the basic integration   rule:</p><p><code>key</code> <span>$= 7, 9, 11, 13$</span> selects the cubature rule of degree <code>key</code>.   Note that the degree-11 rule is available only in 3 dimensions, the   degree-13 rule only in 2 dimensions.</p><p>For other values, the default rule is taken, which is the degree-13   rule in 2 dimensions, the degree-11 rule in 3 dimensions, and the   degree-9 rule otherwise.</p></li></ul><h3 id="Output"><a class="docs-heading-anchor" href="#Output">Output</a><a id="Output-1"></a><a class="docs-heading-anchor-permalink" href="#Output" title="Permalink"></a></h3><p>The integrating functions <a href="#Cuba.vegas"><code>vegas</code></a>, <a href="#Cuba.suave"><code>suave</code></a>, <a href="#Cuba.divonne"><code>divonne</code></a>, and <a href="#Cuba.cuhre"><code>cuhre</code></a> return an <code>Integral</code> object whose fields are</p><pre><code class="language- julia hljs">integral :: Vector{Float64}
error    :: Vector{Float64}
probl    :: Vector{Float64}
neval    :: Int64
fail     :: Int32
nregions :: Int32</code></pre><p>The first three fields are arrays with length <code>ncomp</code>, the last three ones are scalars. The <code>Integral</code> object can also be iterated over like a tuple. In particular, if you assign the output of integrator functions to the variable named <code>result</code>, you can access the value of the <code>i</code>-th component of the integral with <code>result[1][i]</code> or <code>result.integral[i]</code> and the associated error with <code>result[2][i]</code> or <code>result.error[i]</code>.</p><ul><li><code>integral</code> (type: <code>Vector{Float64}</code>, with <code>ncomp</code> components): the   integral of <code>integrand</code> over the unit hypercube</li><li><code>error</code> (type: <code>Vector{Float64}</code>, with <code>ncomp</code> components): the   presumed absolute error for each component of <code>integral</code></li><li><code>probability</code> (type: <code>Vector{Float64}</code>, with <code>ncomp</code> components):   the <span>$\chi^2$</span> -probability (not the <span>$\chi^2$</span> -value itself!) that   <code>error</code> is not a reliable estimate of the true integration error. To   judge the reliability of the result expressed through <code>prob</code>,   remember that it is the null hypothesis that is tested by the   <span>$\chi^2$</span> test, which is that <code>error</code> is a reliable estimate. In   statistics, the null hypothesis may be rejected only if <code>prob</code> is   fairly close to unity, say <code>prob</code> <span>$&gt;.95$</span></li><li><code>neval</code> (type: <code>Int64</code>): the actual number of integrand evaluations   needed</li><li><code>fail</code> (type: <code>Int32</code>): an error flag:<ul><li><code>fail</code> = <code>0</code>, the desired accuracy was reached</li><li><code>fail</code> = <code>-1</code>, dimension out of range</li><li><code>fail</code> &gt; <code>0</code>, the accuracy goal was not met within the allowed   maximum number of integrand evaluations. While Vegas, Suave, and   Cuhre simply return <code>1</code>, Divonne can estimate the number of   points by which <code>maxevals</code> needs to be increased to reach the   desired accuracy and returns this value.</li></ul></li><li><code>nregions</code> (type: <code>Int32</code>): the actual number of subregions needed   (always <code>0</code> in <a href="#Cuba.vegas"><code>vegas</code></a>)</li></ul><h2 id="Vectorization"><a class="docs-heading-anchor" href="#Vectorization">Vectorization</a><a id="Vectorization-1"></a><a class="docs-heading-anchor-permalink" href="#Vectorization" title="Permalink"></a></h2><p>Vectorization means evaluating the integrand function for several points at once. This is also known as <a href="https://en.wikipedia.org/wiki/SIMD">Single Instruction Multiple Data</a> (SIMD) paradigm and is different from ordinary parallelization where independent threads are executed concurrently. It is usually possible to employ vectorization on top of parallelization.</p><p><code>Cuba.jl</code> cannot automatically vectorize the integrand function, of course, but it does pass (up to) <code>nvec</code> points per integrand call (<a href="#Common-Keywords">Common Keywords</a>). This value need not correspond to the hardware vector length –computing several points in one call can also make sense e.g. if the computations have significant intermediate results in common.</p><p>When <code>nvec</code> &gt; 1, the input <code>x</code> is a matrix of dimensions <code>(ndim, nvec)</code>, while the output <code>f</code> is a matrix with dimensions <code>(ncomp, nvec)</code>. Vectorization can be used to evaluate more quickly the integrand function, for example by exploiting parallelism, thus speeding up computation of the integral. See the section <a href="#Vectorized-Function">Vectorized Function</a> below for an example of a vectorized funcion.</p><div class="admonition is-info"><header class="admonition-header">Disambiguation</header><div class="admonition-body"><p>The <code>nbatch</code> argument of <a href="#Cuba.vegas"><code>vegas</code></a> is related in purpose but not identical to <code>nvec</code>. It internally partitions the sampling done by Vegas but has no bearing on the number of points given to the integrand. On the other hand, it it pointless to choose <code>nvec</code> &gt; <code>nbatch</code> for Vegas.</p></div></div><h2 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h2><h3 id="One-dimensional-integral"><a class="docs-heading-anchor" href="#One-dimensional-integral">One dimensional integral</a><a id="One-dimensional-integral-1"></a><a class="docs-heading-anchor-permalink" href="#One-dimensional-integral" title="Permalink"></a></h3><p>The integrand of</p><p class="math-container">\[\int_{0}^{1} \frac{\log(x)}{\sqrt{x}} \,\mathrm{d}x\]</p><p>has an algebraic-logarithmic divergence for <span>$x = 0$</span>, but the integral is convergent and its value is <span>$-4$</span>. <code>Cuba.jl</code> integrator routines can handle this class of functions and you can easily compute the numerical approximation of this integral using one of the following commands:</p><pre><code class="language-julia-repl hljs">julia&gt; vegas( (x,f) -&gt; f[1] = log(x[1])/sqrt(x[1]))
Component:
 1: -3.9981623937128448 ± 0.00044066437168409865 (prob.: 0.28430529712907515)
Integrand evaluations: 1007500
Number of subregions:  0
Note: The accuracy was not met within the maximum number of evaluations

julia&gt; suave( (x,f) -&gt; f[1] = log(x[1])/sqrt(x[1]))
Component:
 1: -4.000246664970977 ± 0.00039262438882794375 (prob.: 1.0)
Integrand evaluations: 50000
Number of subregions:  50
Note: The desired accuracy was reached

julia&gt; divonne( (x,f) -&gt; f[1] = log(x[1])/sqrt(x[1]), atol = 1e-8, rtol = 1e-8)
Component:
 1: -3.999999899620808 ± 2.1865962888458758e-7 (prob.: 0.0)
Integrand evaluations: 1002059
Number of subregions:  1582
Note: The accuracy was not met within the maximum number of evaluations
Hint: Try increasing `maxevals` to 4884287

julia&gt; cuhre( (x,f) -&gt; f[1] = log(x[1])/sqrt(x[1]))
Component:
 1: -4.000000355067185 ± 0.00033954840286260385 (prob.: 0.0)
Integrand evaluations: 5915
Number of subregions:  46
Note: The desired accuracy was reached</code></pre><h3 id="Vector-valued-integrand"><a class="docs-heading-anchor" href="#Vector-valued-integrand">Vector-valued integrand</a><a id="Vector-valued-integrand-1"></a><a class="docs-heading-anchor-permalink" href="#Vector-valued-integrand" title="Permalink"></a></h3><p>Consider the integral</p><p class="math-container">\[\int\limits_{\Omega}
\boldsymbol{f}(x,y,z)\,\mathrm{d}x\,\mathrm{d}y\,\mathrm{d}z\]</p><p>where <span>$\Omega = [0, 1]^{3}$</span> and</p><p class="math-container">\[\boldsymbol{f}(x,y,z) = \left(\sin(x)\cos(y)\exp(z), \,\exp(-(x^2 + y^2 +
z^2)), \,\frac{1}{1 - xyz}\right)\]</p><p>In this case it is more convenient to write a simple Julia script to compute the above integral</p><pre><code class="language-julia-repl hljs">julia&gt; using Cuba, SpecialFunctions

julia&gt; function integrand(x, f)
           f[1] = sin(x[1])*cos(x[2])*exp(x[3])
           f[2] = exp(-(x[1]^2 + x[2]^2 + x[3]^2))
           f[3] = 1/(1 - prod(x))
       end
integrand (generic function with 1 method)

julia&gt; result, err = cuhre(integrand, 3, 3, atol=1e-12, rtol=1e-10);

julia&gt; answer = ((ℯ-1)*(1-cos(1))*sin(1), (sqrt(pi)*erf(1)/2)^3, zeta(3));

julia&gt; for i = 1:3
           println(&quot;Component &quot;, i)
           println(&quot; Result of Cuba: &quot;, result[i], &quot; ± &quot;, err[i])
           println(&quot; Exact result:   &quot;, answer[i])
           println(&quot; Actual error:   &quot;, abs(result[i] - answer[i]))
       end
Component 1
 Result of Cuba: 0.6646696797813743 ± 1.0083313461375621e-13
 Exact result:   0.6646696797813771
 Actual error:   2.886579864025407e-15
Component 2
 Result of Cuba: 0.4165383858806458 ± 2.9328672381493003e-11
 Exact result:   0.41653838588663805
 Actual error:   5.992262241960589e-12
Component 3
 Result of Cuba: 1.202056903164971 ± 1.195855757269273e-10
 Exact result:   1.2020569031595951
 Actual error:   5.375921929839933e-12</code></pre><h3 id="Integral-with-non-constant-boundaries"><a class="docs-heading-anchor" href="#Integral-with-non-constant-boundaries">Integral with non-constant boundaries</a><a id="Integral-with-non-constant-boundaries-1"></a><a class="docs-heading-anchor-permalink" href="#Integral-with-non-constant-boundaries" title="Permalink"></a></h3><p>The integral</p><p class="math-container">\[\int_{-y}^{y}\int_{0}^{z}\int_{0}^{\pi}
\cos(x)\sin(y)\exp(z)\,\mathrm{d}x\,\mathrm{d}y\,\mathrm{d}z\]</p><p>has non-constant boundaries. By applying the substitution rule repeatedly, you can scale the integrand function and get this equivalent integral over the fixed domain <span>$\Omega = [0, 1]^{3}$</span></p><p class="math-container">\[\int\limits_{\Omega} 2\pi^{3}yz^2 \cos(\pi yz(2x - 1)) \sin(\pi yz)
\exp(\pi z)\,\mathrm{d}x\,\mathrm{d}y\,\mathrm{d}z\]</p><p>that can be computed with <code>Cuba.jl</code> using the following Julia script</p><pre><code class="language-julia-repl hljs">julia&gt; using Cuba

julia&gt; function integrand(x, f)
           f[1] = 2pi^3*x[2]*x[3]^2*cos(pi*x[2]*x[3]*(2*x[1] - 1.0))*
                  sin(pi*x[2]*x[3])*exp(pi*x[3])
       end
integrand (generic function with 1 method)

julia&gt; result, err = cuhre(integrand, 3, 1, atol=1e-12, rtol=1e-10);

julia&gt; answer = pi*ℯ^pi - (4ℯ^pi - 4)/5;

julia&gt; begin
               println(&quot;Result of Cuba: &quot;, result[1], &quot; ± &quot;, err[1])
               println(&quot;Exact result:   &quot;, answer)
               println(&quot;Actual error:   &quot;, abs(result[1] - answer))
       end
Result of Cuba: 54.98607586826152 ± 5.460606620717379e-9
Exact result:   54.98607586789537
Actual error:   3.6614977716453723e-10</code></pre><h3 id="Integrals-over-Infinite-Domains"><a class="docs-heading-anchor" href="#Integrals-over-Infinite-Domains">Integrals over Infinite Domains</a><a id="Integrals-over-Infinite-Domains-1"></a><a class="docs-heading-anchor-permalink" href="#Integrals-over-Infinite-Domains" title="Permalink"></a></h3><p><code>Cuba.jl</code> assumes always as integration domain the hypercube <span>$[0, 1]^n$</span>, but we have seen that using integration by substitution we can calculate integrals over different domains as well. In the <a href="#Introduction">Introduction</a> we also proposed two useful substitutions that can be employed to change an infinite or semi-infinite domain into a finite one.</p><p>As a first example, consider the following integral with a semi-infinite domain:</p><p class="math-container">\[\int_{0}^{\infty}\frac{\log(1 + x^2)}{1 + x^2}\,\mathrm{d}x\]</p><p>whose exact result is <span>$\pi\log 2$</span>. This can be computed as follows:</p><pre><code class="language-julia-repl hljs">julia&gt; using Cuba

julia&gt; # The function we want to integrate over [0, ∞).

julia&gt; func(x) = log(1 + x^2)/(1 + x^2)
func (generic function with 1 method)

julia&gt; # Scale the function in order to integrate over [0, 1].

julia&gt; function integrand(x, f)
           f[1] = func(x[1]/(1 - x[1]))/(1 - x[1])^2
       end
integrand (generic function with 1 method)

julia&gt; result, err = cuhre(integrand, atol = 1e-12, rtol = 1e-10);

julia&gt; answer = pi*log(2);

julia&gt; begin
               println(&quot;Result of Cuba: &quot;, result[1], &quot; ± &quot;, err[1])
               println(&quot;Exact result:   &quot;, answer)
               println(&quot;Actual error:   &quot;, abs(result[1] - answer))
       end
Result of Cuba: 2.1775860903056903 ± 2.153947023352171e-10
Exact result:   2.177586090303602
Actual error:   2.0881074647149944e-12</code></pre><p>Now we want to calculate this integral, over an infinite domain</p><p class="math-container">\[\int_{-\infty}^{\infty} \frac{1 - \cos x}{x^2}\,\mathrm{d}x\]</p><p>which gives <span>$\pi$</span>. You can calculate the result with the code below. Note that integrand function has value <span>$1/2$</span> for <span>$x=0$</span>, but you have to inform Julia about this.</p><pre><code class="language-julia-repl hljs">julia&gt; using Cuba

julia&gt; # The function we want to integrate over (-∞, ∞).

julia&gt; func(x) = x==0 ? 0.5*one(x) : (1 - cos(x))/x^2
func (generic function with 1 method)

julia&gt; # Scale the function in order to integrate over [0, 1].

julia&gt; function integrand(x, f)
           f[1] = func((2*x[1] - 1)/x[1]/(1 - x[1])) *
                   (2*x[1]^2 - 2*x[1] + 1)/x[1]^2/(1 - x[1])^2
       end
integrand (generic function with 1 method)

julia&gt; result, err = cuhre(integrand, atol = 1e-7, rtol = 1e-7);

julia&gt; answer = float(pi);

julia&gt; begin
               println(&quot;Result of Cuba: &quot;, result[1], &quot; ± &quot;, err[1])
               println(&quot;Exact result:   &quot;, answer)
               println(&quot;Actual error:   &quot;, abs(result[1] - answer))
       end
Result of Cuba: 3.1415928900554886 ± 2.050669142055499e-6
Exact result:   3.141592653589793
Actual error:   2.3646569546897922e-7</code></pre><h3 id="Complex-integrand"><a class="docs-heading-anchor" href="#Complex-integrand">Complex integrand</a><a id="Complex-integrand-1"></a><a class="docs-heading-anchor-permalink" href="#Complex-integrand" title="Permalink"></a></h3><p>As already explained, <code>Cuba.jl</code> operates on real quantities, so if you want to integrate a complex-valued function of complex arguments you have to treat complex quantities as 2-component arrays of real numbers.  For example, if you do not remember <a href="https://en.wikipedia.org/wiki/Euler%27s_formula">Euler&#39;s formula</a>, you can compute this simple integral</p><p class="math-container">\[\int_{0}^{\pi/2} \exp(\mathrm{i} x)\,\mathrm{d}x\]</p><p>with the following code</p><pre><code class="language-julia-repl hljs">julia&gt; using Cuba

julia&gt; function integrand(x, f)
           # Complex integrand, scaled to integrate in [0, 1].
           tmp = cis(x[1]*pi/2)*pi/2
           # Assign to two components of &quot;f&quot; the real
           # and imaginary part of the integrand.
           f[1], f[2] = reim(tmp)
       end
integrand (generic function with 1 method)

julia&gt; result = cuhre(integrand, 2, 2);

julia&gt; begin
           println(&quot;Result of Cuba: &quot;, complex(result[1]...))
           println(&quot;Exact result:   &quot;, complex(1.0, 1.0))
       end
Result of Cuba: 1.0000000000000002 + 1.0000000000000002im
Exact result:   1.0 + 1.0im</code></pre><h3 id="Passing-data-to-the-integrand-function"><a class="docs-heading-anchor" href="#Passing-data-to-the-integrand-function">Passing data to the integrand function</a><a id="Passing-data-to-the-integrand-function-1"></a><a class="docs-heading-anchor-permalink" href="#Passing-data-to-the-integrand-function" title="Permalink"></a></h3><p>Cuba Library allows program written in C and Fortran to pass extra data to the integrand function with <code>userdata</code> argument. This is useful, for example, when the integrand function depends on changing parameters. In <code>Cuba.jl</code> the <code>userdata</code> argument is not available, but you do not normally need it.</p><p>For example, the <a href="https://en.wikipedia.org/wiki/Cumulative_distribution_function">cumulative distribution function</a> <span>$F(x;k)$</span> of <a href="https://en.wikipedia.org/wiki/Chi-squared_distribution">chi-squared distribution</a> is defined by</p><p class="math-container">\[F(x; k) = \int_{0}^{x} \frac{t^{k/2 - 1}\exp(-t/2)}{2^{k/2}\Gamma(k/2)}
\,\mathrm{d}t\]</p><p>The cumulative distribution function depends on parameter <span>$k$</span>, but the function passed as integrand to <code>Cuba.jl</code> integrator routines accepts as arguments only the input and output vectors. However you can easily define a function to calculate a numerical approximation of <span>$F(x; k)$</span> based on the above integral expression because the integrand can access any variable visible in its <a href="https://docs.julialang.org/en/v1/manual/variables-and-scoping/">scope</a>. The following Julia script computes <span>$F(x = \pi; k)$</span> for different <span>$k$</span> and compares the result with more precise values, based on the analytic expression of the cumulative distribution function, provided by <a href="https://github.com/jiahao/GSL.jl">GSL.jl</a> package.</p><pre><code class="language-julia hljs">julia&gt; using Cuba, GSL, Printf, SpecialFunctions

julia&gt; function chi2cdf(x::Real, k::Real)
           k2 = k/2
           # Chi-squared probability density function, without constant denominator.
           # The result of integration will be divided by that factor.
           function chi2pdf(t::Float64)
               # &quot;k2&quot; is taken from the outside.
               return t^(k2 - 1.0)*exp(-t/2)
           end
           # Neither &quot;x&quot; is passed directly to the integrand function,
           # but is visible to it.  &quot;x&quot; is used to scale the function
           # in order to actually integrate in [0, 1].
           x*cuhre((t,f) -&gt; f[1] = chi2pdf(t[1]*x))[1][1]/(2^k2*gamma(k2))
       end
chi2cdf (generic function with 1 method)

julia&gt; x = float(pi);

julia&gt; begin
            @printf(&quot;Result of Cuba: %.6f %.6f %.6f %.6f %.6f\n&quot;,
                    map((k) -&gt; chi2cdf(x, k), collect(1:5))...)
            @printf(&quot;Exact result:   %.6f %.6f %.6f %.6f %.6f\n&quot;,
                    map((k) -&gt; cdf_chisq_P(x, k), collect(1:5))...)
        end
Result of Cuba: 0.923681 0.792120 0.629694 0.465584 0.321833
Exact result:   0.923681 0.792120 0.629695 0.465584 0.321833</code></pre><h3 id="Vectorized-Function"><a class="docs-heading-anchor" href="#Vectorized-Function">Vectorized Function</a><a id="Vectorized-Function-1"></a><a class="docs-heading-anchor-permalink" href="#Vectorized-Function" title="Permalink"></a></h3><p>Consider the integral</p><p class="math-container">\[\int\limits_{\Omega} \prod_{i=1}^{10} \cos(x_{i})
\,\mathrm{d}\boldsymbol{x} = \sin(1)^{10} = 0.1779883\dots\]</p><p>where <span>$\Omega = [0, 1]^{10}$</span> and <span>$\boldsymbol{x} = (x_{1}, \dots, x_{10})$</span> is a 10-dimensional vector. A simple way to compute this integral is the following:</p><pre><code class="language- julia hljs">julia&gt; using Cuba, BenchmarkTools

julia&gt; cuhre((x, f) -&gt; f[] = prod(cos.(x)), 10)
Component:
 1: 0.17798706658707045 ± 1.070799596273229e-6 (prob.: 0.2438374079277991)
Integrand evaluations: 7815
Number of subregions:  2
Note: The desired accuracy was reached

julia&gt; @benchmark cuhre((x, f) -&gt; f[] = prod(cos.(x)), 10)
BenchmarkTools.Trial: 2448 samples with 1 evaluation.
 Range (min … max):  1.714 ms …   7.401 ms  ┊ GC (min … max): 0.00% … 75.31%
 Time  (median):     1.820 ms               ┊ GC (median):    0.00%
 Time  (mean ± σ):   2.035 ms ± 858.367 μs  ┊ GC (mean ± σ):  9.08% ± 14.32%

  ██▅▅▄▁                                                   ▁  ▁
  ███████▇▆▆▄▁▄▁▁▁▄▃▃▅▁▁▃▃▁▃▃▁▁▃▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▃▁▁▅▆▇▇██▇ █
  1.71 ms      Histogram: log(frequency) by time      5.97 ms &lt;

 Memory estimate: 2.03 MiB, allocs estimate: 39078.</code></pre><p>We can use vectorization in order to speed up evaluation of the integrand function.</p><pre><code class="language-julia hljs">julia&gt; function fun_vec(x,f)
           f[1,:] .= 1.0
           for j in 1:size(x,2)
               for i in 1:size(x, 1)
                   f[1, j] *= cos(x[i, j])
               end
           end
       end
fun_vec (generic function with 1 method)

julia&gt; cuhre(fun_vec, 10, nvec = 1000)
Component:
 1: 0.17798706658707045 ± 1.070799596273229e-6 (prob.: 0.2438374079277991)
Integrand evaluations: 7815
Number of subregions:  2
Note: The desired accuracy was reached

julia&gt; @benchmark cuhre(fun_vec, 10, nvec = 1000)
BenchmarkTools.Trial: 4971 samples with 1 evaluation.
 Range (min … max):  951.837 μs …  1.974 ms  ┊ GC (min … max): 0.00% … 0.00%
 Time  (median):     981.597 μs              ┊ GC (median):    0.00%
 Time  (mean ± σ):     1.001 ms ± 69.101 μs  ┊ GC (mean ± σ):  0.00% ± 0.00%

  █▂  ▁▆▇▁▂▂▂▆▅▂▁▁▁▁                                           ▁
  ██▇▆█████████████████████▇██▇████▇▆▇█▆▆▆▇▆▅▆▆█▇▅▅▅▅▄▅▆▄▅▄▂▃▂ █
  952 μs        Histogram: log(frequency) by time      1.24 ms &lt;

 Memory estimate: 1.59 KiB, allocs estimate: 39.</code></pre><p>A further speed up can be gained by running the <code>for</code> loop in parallel with <code>Threads.@threads</code>. For example, running Julia with 4 threads:</p><pre><code class="language-julia hljs">julia&gt; function fun_par(x,f)
           f[1,:] .= 1.0
           Threads.@threads for j in 1:size(x,2)
               for i in 1:size(x, 1)
                   f[1, j] *= cos(x[i, j])
               end
           end
       end
fun_par (generic function with 1 method)

julia&gt; cuhre(fun_par, 10, nvec = 1000)
Component:
 1: 0.17798706658707045 ± 1.070799596273229e-6 (prob.: 0.2438374079277991)
Integrand evaluations: 7815
Number of subregions:  2
Note: The desired accuracy was reached

julia&gt; @benchmark cuhre(fun_par, 10, nvec = 1000)
BenchmarkTools.Trial: 6198 samples with 1 evaluation.
 Range (min … max):  587.456 μs …   7.076 ms  ┊ GC (min … max): 0.00% … 0.00%
 Time  (median):     798.933 μs               ┊ GC (median):    0.00%
 Time  (mean ± σ):   801.498 μs ± 149.908 μs  ┊ GC (mean ± σ):  0.18% ± 1.50%

                            ▇█▇▃
  ▂▄▆▃▂▃▃▂▂▂▂▂▂▁▂▁▁▁▁▂▄▅▃▂▅██████▆▆▆▆▆█▇▇▆▄▄▃▂▃▂▂▂▂▂▂▁▂▁▁▁▁▁▁▁▁ ▃
  587 μs           Histogram: frequency by time         1.03 ms &lt;

 Memory estimate: 19.31 KiB, allocs estimate: 228.</code></pre><h2 id="Performance"><a class="docs-heading-anchor" href="#Performance">Performance</a><a id="Performance-1"></a><a class="docs-heading-anchor-permalink" href="#Performance" title="Permalink"></a></h2><p><code>Cuba.jl</code> cannot (<a href="https://github.com/giordano/Cuba.jl/issues/1">yet?</a>) take advantage of parallelization capabilities of Cuba Library. Nonetheless, it has performances comparable with equivalent native C or Fortran codes based on Cuba library when <code>CUBACORES</code> environment variable is set to <code>0</code> (i.e., multithreading is disabled). The following is the result of running the benchmark present in <code>test</code> directory on a 64-bit GNU/Linux system running Julia 0.7.0-beta2.3 (commit 83ce9c7524) equipped with an Intel(R) Core(TM) i7-4700MQ CPU. The C and FORTRAN 77 benchmark codes have been compiled with GCC 7.3.0.</p><pre><code class="nohighlight hljs">$ CUBACORES=0 julia -e &#39;using Pkg; import Cuba; include(joinpath(dirname(dirname(pathof(Cuba))), &quot;benchmarks&quot;, &quot;benchmark.jl&quot;))&#39;
[ Info: Performance of Cuba.jl:
  0.257360 seconds (Vegas)
  0.682703 seconds (Suave)
  0.329552 seconds (Divonne)
  0.233190 seconds (Cuhre)
[ Info: Performance of Cuba Library in C:
  0.268249 seconds (Vegas)
  0.682682 seconds (Suave)
  0.319553 seconds (Divonne)
  0.234099 seconds (Cuhre)
[ Info: Performance of Cuba Library in Fortran:
  0.233532 seconds (Vegas)
  0.669809 seconds (Suave)
  0.284515 seconds (Divonne)
  0.195740 seconds (Cuhre)</code></pre><p>Of course, native C and Fortran codes making use of Cuba Library outperform <code>Cuba.jl</code> when higher values of <code>CUBACORES</code> are used, for example:</p><pre><code class="nohighlight hljs">$ CUBACORES=1 julia -e &#39;using Pkg; cd(Pkg.dir(&quot;Cuba&quot;)); include(&quot;test/benchmark.jl&quot;)&#39;
[ Info: Performance of Cuba.jl:
  0.260080 seconds (Vegas)
  0.677036 seconds (Suave)
  0.342396 seconds (Divonne)
  0.233280 seconds (Cuhre)
[ Info: Performance of Cuba Library in C:
  0.096388 seconds (Vegas)
  0.574647 seconds (Suave)
  0.150003 seconds (Divonne)
  0.102817 seconds (Cuhre)
[ Info: Performance of Cuba Library in Fortran:
  0.094413 seconds (Vegas)
  0.556084 seconds (Suave)
  0.139606 seconds (Divonne)
  0.107335 seconds (Cuhre)</code></pre><p><code>Cuba.jl</code> internally fixes <code>CUBACORES</code> to 0 in order to prevent from forking <code>julia</code> processes that would only slow down calculations eating up the memory, without actually taking advantage of concurrency. Furthemore, without this measure, adding more Julia processes with <code>addprocs()</code> would only make the program segfault.</p><h2 id="Related-projects"><a class="docs-heading-anchor" href="#Related-projects">Related projects</a><a id="Related-projects-1"></a><a class="docs-heading-anchor-permalink" href="#Related-projects" title="Permalink"></a></h2><p>There are other Julia packages for multidimenensional numerical integration:</p><ul><li><a href="https://github.com/stevengj/Cubature.jl"><code>Cubature.jl</code></a></li><li><a href="https://github.com/stevengj/HCubature.jl"><code>HCubature.jl</code></a></li><li><a href="https://github.com/pabloferz/NIntegration.jl"><code>NIntegration.jl</code></a></li></ul><h2 id="Development"><a class="docs-heading-anchor" href="#Development">Development</a><a id="Development-1"></a><a class="docs-heading-anchor-permalink" href="#Development" title="Permalink"></a></h2><p><code>Cuba.jl</code> is developed on GitHub: <a href="https://github.com/giordano/Cuba.jl">https://github.com/giordano/Cuba.jl</a>. Feel free to report bugs and make suggestions at <a href="https://github.com/giordano/Cuba.jl/issues">https://github.com/giordano/Cuba.jl/issues</a>.</p><h3 id="History"><a class="docs-heading-anchor" href="#History">History</a><a id="History-1"></a><a class="docs-heading-anchor-permalink" href="#History" title="Permalink"></a></h3><p>The ChangeLog of the package is available in <a href="https://github.com/giordano/Cuba.jl/blob/master/NEWS.md">NEWS.md</a> file in top directory. There have been some breaking changes from time to time, beware of them when upgrading the package.</p><h2 id="License"><a class="docs-heading-anchor" href="#License">License</a><a id="License-1"></a><a class="docs-heading-anchor-permalink" href="#License" title="Permalink"></a></h2><p>The Cuba.jl package is licensed under the GNU Lesser General Public License, the same as <a href="http://www.feynarts.de/cuba/">Cuba library</a>. The original author is Mosè Giordano.</p><h2 id="Credits"><a class="docs-heading-anchor" href="#Credits">Credits</a><a id="Credits-1"></a><a class="docs-heading-anchor-permalink" href="#Credits" title="Permalink"></a></h2><p>If you use this library for your work, please credit Thomas Hahn. Citable papers about Cuba Library:</p><ul><li>Hahn, T. 2005, Computer Physics Communications, 168, 78. DOI:<a href="http://dx.doi.org/10.1016/j.cpc.2005.01.010">10.1016/j.cpc.2005.01.010</a>. arXiv:<a href="http://arxiv.org/abs/hep-ph/0404043">hep-ph/0404043</a>. Bibcode:<a href="http://adsabs.harvard.edu/abs/2005CoPhC.168...78H">2005CoPhC.168…78H</a>.</li><li>Hahn, T. 2015, Journal of Physics Conference Series, 608, 012066. DOI:<a href="http://dx.doi.org/10.1088/1742-6596/608/1/012066">10.1088/1742-6596/608/1/012066</a>. arXiv:<a href="http://arxiv.org/abs/1408.6373">1408.6373</a>. Bibcode:<a href="http://adsabs.harvard.edu/abs/2015JPhCS.608a2066H">2015JPhCS.608a2066H</a>.</li></ul></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Friday 16 September 2022 12:27">Friday 16 September 2022</span>. Using Julia version 1.8.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
